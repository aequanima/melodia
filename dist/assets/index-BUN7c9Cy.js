var v=Object.defineProperty;var x=(h,t,e)=>t in h?v(h,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):h[t]=e;var r=(h,t,e)=>x(h,typeof t!="symbol"?t+"":t,e);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))i(n);new MutationObserver(n=>{for(const s of n)if(s.type==="childList")for(const o of s.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&i(o)}).observe(document,{childList:!0,subtree:!0});function e(n){const s={};return n.integrity&&(s.integrity=n.integrity),n.referrerPolicy&&(s.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?s.credentials="include":n.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function i(n){if(n.ep)return;n.ep=!0;const s=e(n);fetch(n.href,s)}})();var u=(h=>(h.MOUSE="mouse",h.TOUCH="touch",h.PEN="pen",h))(u||{});class b{constructor(t){r(this,"canvas");r(this,"activeTouches",new Map);r(this,"callbacks",{onStart:[],onMove:[],onEnd:[]});this.canvas=t,this.setupEventListeners()}setupEventListeners(){this.canvas.addEventListener("touchstart",this.handleTouchStart.bind(this),{passive:!1}),this.canvas.addEventListener("touchmove",this.handleTouchMove.bind(this),{passive:!1}),this.canvas.addEventListener("touchend",this.handleTouchEnd.bind(this),{passive:!1}),this.canvas.addEventListener("touchcancel",this.handleTouchEnd.bind(this),{passive:!1}),this.canvas.addEventListener("mousedown",this.handleMouseDown.bind(this)),this.canvas.addEventListener("mousemove",this.handleMouseMove.bind(this)),this.canvas.addEventListener("mouseup",this.handleMouseUp.bind(this)),this.canvas.addEventListener("mouseleave",this.handleMouseUp.bind(this)),this.canvas.addEventListener("contextmenu",t=>t.preventDefault())}getCanvasPoint(t,e){const i=this.canvas.getBoundingClientRect();return{x:t-i.left,y:e-i.top,timestamp:performance.now()}}handleTouchStart(t){t.preventDefault();for(let e=0;e<t.changedTouches.length;e++){const i=t.changedTouches[e],n=this.getCanvasPoint(i.clientX,i.clientY);this.activeTouches.set(i.identifier,{id:i.identifier,startPoint:n,currentPoint:n,lastTimestamp:n.timestamp});const s={type:u.TOUCH,point:n,isStart:!0,isEnd:!1,id:i.identifier};this.callbacks.onStart.forEach(o=>o(s))}}handleTouchMove(t){t.preventDefault();for(let e=0;e<t.changedTouches.length;e++){const i=t.changedTouches[e],n=this.activeTouches.get(i.identifier);if(!n)continue;const s=this.getCanvasPoint(i.clientX,i.clientY);n.currentPoint=s;const o={type:u.TOUCH,point:s,isStart:!1,isEnd:!1,id:i.identifier};this.callbacks.onMove.forEach(a=>a(o))}}handleTouchEnd(t){t.preventDefault();for(let e=0;e<t.changedTouches.length;e++){const i=t.changedTouches[e];if(!this.activeTouches.get(i.identifier))continue;const s=this.getCanvasPoint(i.clientX,i.clientY),o={type:u.TOUCH,point:s,isStart:!1,isEnd:!0,id:i.identifier};this.callbacks.onEnd.forEach(a=>a(o)),this.activeTouches.delete(i.identifier)}}handleMouseDown(t){console.log("Mouse down event:",t);const e=this.getCanvasPoint(t.clientX,t.clientY);this.activeTouches.set(-1,{id:-1,startPoint:e,currentPoint:e,lastTimestamp:e.timestamp});const i={type:u.MOUSE,point:e,isStart:!0,isEnd:!1,id:-1};console.log("Triggering mouse start callbacks:",i),this.callbacks.onStart.forEach(n=>n(i))}handleMouseMove(t){const e=this.activeTouches.get(-1);if(!e)return;const i=this.getCanvasPoint(t.clientX,t.clientY);e.currentPoint=i;const n={type:u.MOUSE,point:i,isStart:!1,isEnd:!1,id:-1};this.callbacks.onMove.forEach(s=>s(n))}handleMouseUp(t){if(!this.activeTouches.get(-1))return;const i=this.getCanvasPoint(t.clientX,t.clientY),n={type:u.MOUSE,point:i,isStart:!1,isEnd:!0,id:-1};this.callbacks.onEnd.forEach(s=>s(n)),this.activeTouches.delete(-1)}handlePointerDown(t){const e=this.getCanvasPoint(t.clientX,t.clientY);e.pressure=t.pressure,this.activeTouches.set(t.pointerId,{id:t.pointerId,startPoint:e,currentPoint:e,lastTimestamp:e.timestamp});const i={type:t.pointerType==="pen"?u.PEN:u.TOUCH,point:e,isStart:!0,isEnd:!1,id:t.pointerId};this.callbacks.onStart.forEach(n=>n(i))}handlePointerMove(t){const e=this.activeTouches.get(t.pointerId);if(!e)return;const i=this.getCanvasPoint(t.clientX,t.clientY);i.pressure=t.pressure,e.currentPoint=i;const n={type:t.pointerType==="pen"?u.PEN:u.TOUCH,point:i,isStart:!1,isEnd:!1,id:t.pointerId};this.callbacks.onMove.forEach(s=>s(n))}handlePointerUp(t){if(!this.activeTouches.get(t.pointerId))return;const i=this.getCanvasPoint(t.clientX,t.clientY);i.pressure=t.pressure;const n={type:t.pointerType==="pen"?u.PEN:u.TOUCH,point:i,isStart:!1,isEnd:!0,id:t.pointerId};this.callbacks.onEnd.forEach(s=>s(n)),this.activeTouches.delete(t.pointerId)}onStart(t){this.callbacks.onStart.push(t)}onMove(t){this.callbacks.onMove.push(t)}onEnd(t){this.callbacks.onEnd.push(t)}destroy(){this.activeTouches.clear(),this.callbacks.onStart=[],this.callbacks.onMove=[],this.callbacks.onEnd=[]}}class w{constructor(){r(this,"paths",new Map);r(this,"activePaths",new Set);r(this,"pathCounter",0)}startRecording(t){const e=`path-${++this.pathCounter}`,i={...t,timestamp:performance.now()},n={id:e,points:[i],style:this.getDefaultStyle(),boundingBox:this.createBoundingBox(i),createdAt:Date.now()};return this.paths.set(e,n),this.activePaths.add(e),e}addPoint(t,e){const i=this.paths.get(t);if(!i)return;const n={...e,timestamp:performance.now()};i.points.push(n),this.updateBoundingBox(i,n)}endRecording(t){this.activePaths.delete(t)}getPath(t){return this.paths.get(t)}getAllPaths(){return Array.from(this.paths.values())}getActivePaths(){return Array.from(this.activePaths).map(t=>this.paths.get(t)).filter(Boolean)}deletePath(t){this.paths.delete(t),this.activePaths.delete(t)}clearAllPaths(){this.paths.clear(),this.activePaths.clear(),this.pathCounter=0}isRecording(t){return t?this.activePaths.has(t):this.activePaths.size>0}attachAudioData(t,e){const i=this.paths.get(t);if(!i)return;const n=this.calculatePathLength(i),s=this.getRecordingDuration(i),o=n/s;i.audioData={buffer:e,format:"webm",sampleRate:44100,duration:s/1e3,metadata:{recordedAt:i.createdAt,originalSpeed:o}}}getDefaultStyle(){return{strokeWidth:3,strokeColor:"#ffffff",glowIntensity:.5}}createBoundingBox(t){return{x:t.x,y:t.y,width:0,height:0}}updateBoundingBox(t,e){const i=t.boundingBox;e.x<i.x?(i.width+=i.x-e.x,i.x=e.x):e.x>i.x+i.width&&(i.width=e.x-i.x),e.y<i.y?(i.height+=i.y-e.y,i.y=e.y):e.y>i.y+i.height&&(i.height=e.y-i.y)}calculatePathLength(t){let e=0;for(let i=1;i<t.points.length;i++){const n=t.points[i-1],s=t.points[i],o=s.x-n.x,a=s.y-n.y;e+=Math.sqrt(o*o+a*a)}return e}getRecordingDuration(t){if(t.points.length<2)return 0;const e=t.points[0].timestamp;return t.points[t.points.length-1].timestamp-e}findPathAtPoint(t,e=10){for(const[i,n]of this.paths)if(this.isPointNearPath(t,n,e))return i;return null}findNearestPointOnPath(t,e){const i=this.paths.get(e);if(!i)return null;let n=i.points[0],s=this.distanceToPoint(t,n),o=0;const a=this.calculatePathLength(i);let c=0;for(let l=0;l<i.points.length-1;l++){const d=i.points[l],p=i.points[l+1],g=this.closestPointOnLineSegment(t,d,p),m=this.distanceToPoint(t,g);if(m<s){s=m,n=g;const f=this.distanceToPoint(d,p),P=this.distanceToPoint(d,g),y=f>0?P/f:0;o=a>0?(c+y*f)/a:0}c+=this.distanceToPoint(d,p)}return{point:n,progress:Math.max(0,Math.min(1,o))}}distanceToPoint(t,e){const i=t.x-e.x,n=t.y-e.y;return Math.sqrt(i*i+n*n)}closestPointOnLineSegment(t,e,i){const n=t.x-e.x,s=t.y-e.y,o=i.x-e.x,a=i.y-e.y,c=n*o+s*a,l=o*o+a*a;if(l===0)return e;let d=c/l;return d<0&&(d=0),d>1&&(d=1),{x:e.x+d*o,y:e.y+d*a,timestamp:performance.now()}}isPointNearPath(t,e,i){const n=e.boundingBox;if(t.x<n.x-i||t.x>n.x+n.width+i||t.y<n.y-i||t.y>n.y+n.height+i)return!1;for(let s=0;s<e.points.length-1;s++){const o=e.points[s],a=e.points[s+1];if(this.distanceToLineSegment(t,o,a)<=i)return!0}if(e.points.length===1){const s=e.points[0],o=t.x-s.x,a=t.y-s.y;if(Math.sqrt(o*o+a*a)<=i)return!0}return!1}distanceToLineSegment(t,e,i){const n=t.x-e.x,s=t.y-e.y,o=i.x-e.x,a=i.y-e.y,c=n*o+s*a,l=o*o+a*a;if(l===0)return Math.sqrt(n*n+s*s);let d=c/l,p,g;d<0?(p=e.x,g=e.y):d>1?(p=i.x,g=i.y):(p=e.x+d*o,g=e.y+d*a);const m=t.x-p,f=t.y-g;return Math.sqrt(m*m+f*f)}}class M{constructor(t){r(this,"canvas");r(this,"context");r(this,"devicePixelRatio");this.canvas=t,this.context=t.getContext("2d"),this.devicePixelRatio=window.devicePixelRatio||1,this.setupCanvas(),this.setupResizeHandler()}setupCanvas(){this.resize(),this.context.imageSmoothingEnabled=!0,this.context.imageSmoothingQuality="high",this.context.lineCap="round",this.context.lineJoin="round"}setupResizeHandler(){new ResizeObserver(()=>{this.resize()}).observe(this.canvas)}resize(){const t=this.canvas.getBoundingClientRect();this.canvas.width=t.width*this.devicePixelRatio,this.canvas.height=t.height*this.devicePixelRatio,this.context.scale(this.devicePixelRatio,this.devicePixelRatio),this.canvas.style.width=t.width+"px",this.canvas.style.height=t.height+"px"}clear(){const t=this.canvas.getBoundingClientRect();this.context.clearRect(0,0,t.width,t.height)}drawPath(t,e=!1){if(t.points.length<2){this.drawSinglePoint(t.points[0],t.style,e);return}this.context.save(),this.context.strokeStyle=t.style.strokeColor,this.context.lineWidth=t.style.strokeWidth,(e||t.style.glowIntensity>0)&&(this.context.shadowColor=t.style.strokeColor,this.context.shadowBlur=t.style.glowIntensity*20),this.context.beginPath(),this.context.moveTo(t.points[0].x,t.points[0].y);for(let i=1;i<t.points.length-1;i++){const n=t.points[i],s=t.points[i+1],o=(n.x+s.x)/2,a=(n.y+s.y)/2;this.context.quadraticCurveTo(n.x,n.y,o,a)}if(t.points.length>1){const i=t.points[t.points.length-1];this.context.lineTo(i.x,i.y)}this.context.stroke(),this.context.restore()}drawSinglePoint(t,e,i=!1){this.context.save(),this.context.fillStyle=e.strokeColor,(i||e.glowIntensity>0)&&(this.context.shadowColor=e.strokeColor,this.context.shadowBlur=e.glowIntensity*15),this.context.beginPath(),this.context.arc(t.x,t.y,e.strokeWidth/2,0,Math.PI*2),this.context.fill(),this.context.restore()}drawActivePoint(t,e=1){this.context.save();const i=.5+.5*Math.sin(performance.now()*.01);this.context.fillStyle=`rgba(255, 68, 68, ${i*e})`,this.context.shadowColor="#ff4444",this.context.shadowBlur=20*e,this.context.beginPath(),this.context.arc(t.x,t.y,8,0,Math.PI*2),this.context.fill(),this.context.restore()}drawPlaybackIndicator(t,e=1){this.context.save();const i=.8*e;this.context.fillStyle=`rgba(255, 255, 255, ${i})`,this.context.strokeStyle=`rgba(100, 200, 255, ${i})`,this.context.lineWidth=2,this.context.shadowColor="#64c8ff",this.context.shadowBlur=15*e,this.context.beginPath(),this.context.arc(t.x,t.y,6,0,Math.PI*2),this.context.fill(),this.context.stroke(),this.context.restore()}drawAllPaths(t,e){this.clear(),t.forEach(i=>{const n=e.has(i.id);this.drawPath(i,n)})}toDataURL(t="image/png",e){return this.canvas.toDataURL(t,e)}getCanvasSize(){const t=this.canvas.getBoundingClientRect();return{width:t.width,height:t.height}}startAnimationLoop(t){const e=i=>{t(i),requestAnimationFrame(e)};requestAnimationFrame(e)}}class E{constructor(){r(this,"audioContext");r(this,"mediaRecorder");r(this,"stream");r(this,"recordingChunks",[]);r(this,"isInitialized",!1);r(this,"permissionGranted",!1);r(this,"activeSources",new Map);r(this,"audioBuffers",new Map)}async initialize(){if(this.isInitialized)return this.permissionGranted;try{return this.audioContext=new(window.AudioContext||window.webkitAudioContext),console.log("AudioContext created, state:",this.audioContext.state),this.isInitialized=!0,!0}catch(t){return console.warn("Failed to initialize audio context:",t),!1}}async requestMicrophonePermission(){if(this.permissionGranted&&this.stream)return!0;try{return this.audioContext&&this.audioContext.state==="suspended"&&(await this.audioContext.resume(),console.log("AudioContext resumed")),this.stream=await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:!0,noiseSuppression:!0,autoGainControl:!0,sampleRate:44100}}),console.log("Microphone stream obtained successfully"),this.permissionGranted=!0,!0}catch(t){return console.warn("Microphone permission denied or error:",t),this.handlePermissionError(t),!1}}handlePermissionError(t){let e="Unable to access microphone.";t.name==="NotAllowedError"?e="Microphone access was denied. Please enable microphone permissions in your browser settings to record audio while drawing.":t.name==="NotFoundError"?e="No microphone found. Please connect a microphone to record audio.":t.name==="NotSupportedError"&&(e="Audio recording is not supported in this browser."),this.showPermissionDialog(e)}showPermissionDialog(t){const e=document.createElement("div");e.style.cssText=`
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      font-family: system-ui, -apple-system, sans-serif;
    `;const i=document.createElement("div");i.style.cssText=`
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 16px;
      padding: 30px;
      max-width: 400px;
      margin: 20px;
      text-align: center;
      color: white;
    `;const n=document.createElement("p");n.textContent=t,n.style.cssText="margin: 0 0 20px 0; line-height: 1.5;";const s=document.createElement("button");s.textContent="Continue without audio",s.style.cssText=`
      background: rgba(255, 255, 255, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 8px;
      color: white;
      padding: 10px 20px;
      cursor: pointer;
      font-size: 14px;
    `,s.onclick=()=>document.body.removeChild(e),i.appendChild(n),i.appendChild(s),e.appendChild(i),document.body.appendChild(e)}async startRecording(){if(!this.permissionGranted||!this.stream)return console.warn("Cannot start recording: no permission or stream"),!1;try{return this.recordingChunks=[],this.mediaRecorder=new MediaRecorder(this.stream,{mimeType:this.getSupportedMimeType()}),this.mediaRecorder.ondataavailable=t=>{t.data.size>0&&this.recordingChunks.push(t.data)},this.mediaRecorder.start(100),!0}catch(t){return console.error("Failed to start recording:",t),!1}}async stopRecording(){return!this.mediaRecorder||this.mediaRecorder.state==="inactive"?null:new Promise(t=>{if(!this.mediaRecorder){t(null);return}this.mediaRecorder.onstop=async()=>{try{const i=await new Blob(this.recordingChunks,{type:this.mediaRecorder.mimeType}).arrayBuffer();t(i)}catch(e){console.error("Failed to process recording:",e),t(null)}},this.mediaRecorder.stop()})}getSupportedMimeType(){const t=["audio/webm;codecs=opus","audio/webm","audio/mp4","audio/mpeg"];for(const e of t)if(MediaRecorder.isTypeSupported(e))return e;return"audio/webm"}async playAudioAtPosition(t,e,i,n=1){if(!this.audioContext)return console.warn("AudioContext not available"),!1;try{this.stopPlayback(e);let s=this.audioBuffers.get(e);s||(s=await this.audioContext.decodeAudioData(t.slice(0)),this.audioBuffers.set(e,s),console.log(`Decoded audio for ${e}: ${s.duration.toFixed(2)}s`));const o=Math.max(0,Math.min(s.duration-.01,i)),a=Math.max(.5,Math.min(2,n)),c=this.audioContext.createBufferSource();c.buffer=s,c.playbackRate.value=a,c.connect(this.audioContext.destination),this.activeSources.set(e,c),c.onended=()=>{this.activeSources.delete(e),console.log(`Audio ended for ${e}`)};const l=s.duration-o;return c.start(0,o,l),console.log(`Playing ${e} from ${o.toFixed(2)}s at ${a.toFixed(2)}x speed`),!0}catch(s){return console.error("Failed to play audio:",s),!1}}async createLoop(t,e,i,n=.2){if(!this.audioContext)return console.warn("AudioContext not available"),!1;try{this.stopPlayback(e);let s=this.audioBuffers.get(e);s||(s=await this.audioContext.decodeAudioData(t.slice(0)),this.audioBuffers.set(e,s));const o=Math.max(0,Math.min(s.duration-n,i)),a=Math.min(n,s.duration-o);if(a<.05)return console.warn("Loop duration too short"),!1;const c=this.audioContext.createBufferSource();return c.buffer=s,c.loop=!0,c.loopStart=o,c.loopEnd=o+a,c.connect(this.audioContext.destination),this.activeSources.set(e,c),c.onended=()=>{this.activeSources.delete(e),console.log(`Loop ended for ${e}`)},c.start(0,o),console.log(`Started loop for ${e}: ${o.toFixed(2)}s to ${(o+a).toFixed(2)}s`),!0}catch(s){return console.error("Failed to create loop:",s),!1}}stopPlayback(t){const e=this.activeSources.get(t);if(e){try{e.stop(),console.log(`Stopped playback for ${t}`)}catch{}this.activeSources.delete(t)}}stopAllPlayback(){for(const[t,e]of this.activeSources)try{e.stop()}catch{}this.activeSources.clear(),console.log("Stopped all playback")}isPlaying(t){return this.activeSources.has(t)}isRecording(){var t;return((t=this.mediaRecorder)==null?void 0:t.state)==="recording"}isReady(){return this.isInitialized&&this.permissionGranted}getAudioContext(){return this.audioContext}destroy(){this.mediaRecorder&&this.mediaRecorder.state==="recording"&&this.mediaRecorder.stop(),this.stream&&this.stream.getTracks().forEach(t=>t.stop()),this.audioContext&&this.audioContext.state!=="closed"&&this.audioContext.close(),this.stopAllPlayback(),this.audioBuffers.clear(),this.mediaRecorder=void 0,this.stream=void 0,this.audioContext=void 0,this.recordingChunks=[],this.isInitialized=!1,this.permissionGranted=!1}}class C{constructor(){r(this,"canvas");r(this,"touchHandler");r(this,"pathManager");r(this,"renderer");r(this,"audioEngine");r(this,"recordingIndicator");r(this,"currentRecordingPath",null);r(this,"isAppReady",!1);r(this,"playingPaths",new Set);r(this,"playbackIndicators",new Map);r(this,"activePlaybackPath",null);r(this,"lastPlaybackPoint",null);r(this,"lastPlaybackTime",0);r(this,"isMoving",!1);r(this,"movementThreshold",5);r(this,"lastAudioPosition",0);r(this,"positionSmoothingFactor",.3);if(console.log("MelodiaApp constructor called"),this.canvas=document.getElementById("main-canvas"),this.recordingIndicator=document.getElementById("recording-indicator"),!this.canvas)throw console.error("Canvas element not found!"),new Error("Canvas element not found");console.log("Canvas found:",this.canvas),console.log("Canvas dimensions:",this.canvas.clientWidth,"x",this.canvas.clientHeight),this.pathManager=new w,this.renderer=new M(this.canvas),this.audioEngine=new E,this.touchHandler=new b(this.canvas),console.log("All components initialized"),this.setupEventHandlers(),this.init()}async init(){try{try{await this.audioEngine.initialize(),console.log("Audio engine initialized")}catch(t){console.warn("Audio engine failed to initialize, continuing without audio:",t)}this.startRenderLoop(),this.setupPermissionRequest(),this.isAppReady=!0,console.log("Melodia app initialized successfully")}catch(t){console.error("Failed to initialize app:",t),this.isAppReady=!0}}setupEventHandlers(){console.log("Setting up event handlers..."),this.touchHandler.onStart(t=>{this.handleInputStart(t)}),this.touchHandler.onMove(t=>{this.handleInputMove(t)}),this.touchHandler.onEnd(t=>{this.handleInputEnd(t)}),console.log("Event handlers set up successfully")}async handleInputStart(t){if(console.log("Input start event:",t),!this.isAppReady){console.warn("App not ready");return}const e=this.pathManager.findPathAtPoint(t.point,15);if(e){console.log("Clicked on existing path:",e),await this.handlePathPlayback(e,t.point);return}console.log("Starting new path recording"),this.audioEngine.isReady()||(console.log("Requesting microphone permission..."),await this.audioEngine.requestMicrophonePermission()||console.warn("Audio recording not available, continuing with visual-only mode"));let i=!1;this.audioEngine.isReady()&&(i=await this.audioEngine.startRecording(),console.log("Audio recording started:",i)),this.currentRecordingPath=this.pathManager.startRecording(t.point),this.showRecordingIndicator(),console.log("Started recording path:",this.currentRecordingPath)}handleInputMove(t){if(this.isAppReady){if(this.activePlaybackPath&&!this.currentRecordingPath){this.handlePlaybackMove(t.point);return}this.currentRecordingPath&&(this.pathManager.addPoint(this.currentRecordingPath,t.point),console.log("Added point to path:",t.point))}}handlePlaybackMove(t){if(!this.activePlaybackPath||!this.lastPlaybackPoint)return;const e=this.pathManager.getPath(this.activePlaybackPath);if(!e||!e.audioData)return;const i=Math.sqrt(Math.pow(t.x-this.lastPlaybackPoint.x,2)+Math.pow(t.y-this.lastPlaybackPoint.y,2));if(!this.isMoving&&i>this.movementThreshold&&(this.isMoving=!0,console.log("Switched to scrubbing mode")),!this.isMoving)return;const n=performance.now(),s=n-this.lastPlaybackTime;if(s<100)return;const o=this.pathManager.findNearestPointOnPath(t,this.activePlaybackPath);if(!o)return;const a=o.progress*e.audioData.duration;if(Math.abs(a-this.lastAudioPosition)>.05){const l=s>0?i/s*1e3:0,p=Math.max(.5,Math.min(2,l/100));this.audioEngine.playAudioAtPosition(e.audioData.buffer,this.activePlaybackPath,a,p),this.lastAudioPosition=a}this.playbackIndicators.set(this.activePlaybackPath,o.point),this.lastPlaybackPoint=t,this.lastPlaybackTime=n}async handleInputEnd(t){if(this.isAppReady){if(this.activePlaybackPath&&!this.currentRecordingPath){console.log("Ending interactive scrubbing for:",this.activePlaybackPath),this.audioEngine.stopPlayback(this.activePlaybackPath),this.playingPaths.delete(this.activePlaybackPath),this.playbackIndicators.delete(this.activePlaybackPath),this.activePlaybackPath=null,this.lastPlaybackPoint=null,this.isMoving=!1,this.lastAudioPosition=0;return}if(this.currentRecordingPath){this.pathManager.addPoint(this.currentRecordingPath,t.point);const e=await this.audioEngine.stopRecording();e&&this.pathManager.attachAudioData(this.currentRecordingPath,e),this.pathManager.endRecording(this.currentRecordingPath),this.hideRecordingIndicator(),console.log("Finished recording path:",this.currentRecordingPath),this.currentRecordingPath=null}}}startRenderLoop(){const t=()=>{this.renderer.clear();const e=this.pathManager.getAllPaths(),i=new Set([...this.pathManager.getActivePaths().map(n=>n.id),...this.playingPaths]);this.renderer.drawAllPaths(e,i);for(const n of this.playingPaths){const s=this.playbackIndicators.get(n);s&&this.renderer.drawPlaybackIndicator(s)}if(this.currentRecordingPath&&this.pathManager.isRecording(this.currentRecordingPath)){const n=this.pathManager.getPath(this.currentRecordingPath);if(n&&n.points.length>0){const s=n.points[n.points.length-1];this.renderer.drawActivePoint(s)}}requestAnimationFrame(t)};requestAnimationFrame(t)}setupPermissionRequest(){const t=async()=>{this.audioEngine.isReady()||await this.audioEngine.requestMicrophonePermission(),document.removeEventListener("touchstart",t),document.removeEventListener("mousedown",t)};document.addEventListener("touchstart",t,{once:!0}),document.addEventListener("mousedown",t,{once:!0})}showRecordingIndicator(){this.recordingIndicator.classList.remove("hidden")}hideRecordingIndicator(){this.recordingIndicator.classList.add("hidden")}async handlePathPlayback(t,e){const i=this.pathManager.getPath(t);if(!i||!i.audioData){console.log("Path has no audio data:",t);return}const n=this.pathManager.findNearestPointOnPath(e,t);if(!n){console.warn("Could not find nearest point on path");return}const{point:s,progress:o}=n;if(!this.audioEngine.isReady()&&!await this.audioEngine.requestMicrophonePermission()){console.warn("Cannot play audio without audio context");return}this.activePlaybackPath=t,this.lastPlaybackPoint=s,this.lastPlaybackTime=performance.now(),this.isMoving=!1;const a=o*i.audioData.duration;this.lastAudioPosition=a,await this.audioEngine.createLoop(i.audioData.buffer,t,a,.2),console.log("Started playback at position:",t,"at progress:",(o*100).toFixed(1)+"%","position:",a.toFixed(2)+"s"),this.playingPaths.add(t),this.playbackIndicators.set(t,s)}clearCanvas(){this.pathManager.clearAllPaths(),this.renderer.clear()}isRecording(){return this.pathManager.isRecording()}destroy(){this.touchHandler.destroy(),this.audioEngine.destroy()}}document.addEventListener("DOMContentLoaded",()=>{try{new C}catch(h){console.error("Failed to start Melodia app:",h),document.body.innerHTML=`
      <div style="
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100vh;
        font-family: system-ui, -apple-system, sans-serif;
        text-align: center;
        color: white;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      ">
        <div>
          <h1>Melodia</h1>
          <p>Failed to initialize the application.</p>
          <p style="font-size: 14px; opacity: 0.8;">Please refresh the page and try again.</p>
        </div>
      </div>
    `}});document.addEventListener("visibilitychange",()=>{document.hidden?console.log("App hidden, pausing audio context"):console.log("App visible, resuming audio context")});
